---
Date: 2021-05-24
Author: Ruizhe Zhao
---

# Run Phism on Polybench

This is a brief report on how we run Phism on all Polybench examples.

Note that we haven't successfully passed all co-simulation tests. We will talk about this [later](#cosim-issue)

## The Tool

We have a Python library [here](../python/utils/polybench.py), which currently implements all the utilities to launch a Polybench experiment.

You can use it from the [command line](../scripts/pb-flow.py), or within a [Jupyter notebook](../notebooks/polybench-results.ipynb).

## The workflow

Phism takes in C source and produce transformed MLIR/LLVM code, which can later be consumed by Vitis.

The whole pipeline is (you may refer to `PbFlow::run` in [`polybench.py`](../python/utils/polybench.py) for more details):

* `compile_c`: Use `mlir-clang` to compile C to MLIR.
* `preprocess`: Propagate the constants to loop bounds, so that the HLS tool can have a better understanding of the latency.
* `extract_top_func`: Take out the top function into a single MLIR file. A top function starts with `kernel_` following Polybench convention.
* `polymer_opt`: Apply polyhedral transformation provided by Polymer.
* `lower_llvm`: Use MLIR utilities to lower from the Affine level program to LLVM IR.
* `vitis_opt`: Transform the LLVM IR for better Vitis processing.
* `run_vitis`: Launch the Vitis tool-chain.

Depending on whether you want to do co-simulation or not, `run_vitis` has two scenarios:

1. Synthesis-only, which will just synthesize the design generated by Phism.
2. Cosim, which will generate a design from C as well, and run co-simulation between the Phism-version and the C-version.

## Cosim issue

The current co-simulation step has some caveats. It works in the following way: 

1. After we successfully synthesized Phism, we generate testbench from the original C code.
2. Then, we copy the synthezied Phism modules to override the testbench's source.
3. Finally, we run again the testbench, and this time, it will test against the Phism's synthesis product.

It sounds promising, but:

1. Even though the top function interface between C and Phism is the same, we cannot guarantee that the Verilog module has the same interface. For example, some memory might be configured to use one port when synthesized from C, while it may have two ports if it comes from Phism. The testbench won't be adapted to that and the testing should fail.
2. ...

